Dia 1:
npx create-react-app podcastr

SSR (Server Side Rendering) e SSG (Static Site Generation)

SSR:
   Resumindo, quando se faz uma requisição a uma API, o browser quem cria a renderização dos dados. No SSR, existe um segundo "servidor" entre o servidor e o client, que fica responsável por criar a visualização HTML e enviá-la pronta ao client. O Next.js seria esse segundo servidor.

SSG:
   Resumindo, no caso com Next.js, uma página ficará estática e será exibida para todos os usuários. E só será atualizada inserindo um intervalo de tempo


Sair da pasta do podcastr para criarmos um projeto com Next




COMEÇA AQUIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

   npx create-next-app podcastrnext

Limpamos o projeto

yarn dev

código: #missaoespacial


Dia 2:

Configuração do TS no projeto com next

Deixa um terminal rodando a aplicação (yarn dev) e outro para instalações

yarn add typescript @types/react @types/node -D

Converter os arquivos existentes para o formato .tsx (index e app)

tsconfig.json e next-env.d.ts são criado automaticamente

Criar pasta src e jogar a pasta pages lá dentro. A pasta pages só pode ficar alocada na raíz ou na pasta src
   Parar projeto e rodar de novo yarn dev

Criar os estilos globais, em /styles e importar no app.tsx

Utilizaremos o SASS para o css
   yarn add sass
   :root {} são guardadas as váriaveis que são visíveis para todo o projeto

_app é o arquivo global que reúne todos os arquivos (como se fosse o index em react puro). E sempre que for atualizado, o componente terá que carregar tudo novamente.
   Por isso, criamos o _document, que será para importar as fontes

Criar a pasta components, Header
Baixar os arquivos em public



yarn add date-fns

Criar pasta Player


server.json disponibilizado para Baixar

json-server é uma lib para trabalharmos com apis fakes
   yarn add json-server -D
   Criar script "server"

Formas de consumir uma API dentro de react e next

- SPA
   Utilizando o fetch dentro de um useEffect(). Mas pode ser problemático em indexações e crawlers.   

- SSR
   A função getServerSideProps é uma função que faz o next entender que ela sempre precisar ser executada antes de retornar um componente para o usuário
   Dessa forma, sempre que um componente/page for exibido ao usuário, os dados já estarão carregados, pois foram utilizados na camada do next

- SSG
   No SSR, sempre que uma pessoa acessa uma página, o getServerSideProps é acionado, mesmo que os dados retornados não tenham sofrido alterações.
   Dessa forma, fica muito custoso! 
   No SSG, será gerado uma página estática para o primeiro usuário que acessá-la. Quando o próximo usuário acessar a mesma página, ele receberá o mesmo HTML gerado pelo usuário 1, desde que os dados não tenham sido alterados.
   Para isso, ao invés de usar getServerSideProps, utilizar a função getStaticProps

Para vermos de fato o SSG rodando, apenas em produção. Então, gerar a build do projeto.
Para a aplicação next e deixar apenas o servidor!

   yarn build
Quando se faz o build do projeto, é mostrado um log.
Nas pages, o que tem uma bolinha branca simboliza a página gerada com SSG
Se tiver uma lambda (parece um 'A' com crase `), simboliza a página gerada com SSR

   yarn start

#embuscadoproximonivel


Dia 3:
Melhorar a página da Home, adicionando TS
GetStaticProps é um import feito de next, e é uma tipagem para o getStaticProps

Instalar o axios para utilizar no lugar do fetch
   yarn add axios
Criar pasta /services e o arquivo nela

Dica: quando precisar formatar os dados que vem da API, formate-os antes de chegar no return.

Componente Image, do next
   Necessário criar arquivo na raiz chamado next.config.js e informar de onde vem a imagem

Feito a estilização da Home


Roteamento no next

Nova page: episode.tsx

Quando criamos uma page dentro da pasta pages e o arquivo nao inicia com _, o next forma como uma rota da aplicação. Porém, eu não vou saber, no nosso caso, qual episode é! Poderia ficar episode?id=1, mas não fica amigável ao user. Então queremos deixar episodes/o-nome-do-episodio
Então, criar pasta episode dentro de /pages e o arquivo dentro. O nome slug seria o que vem depois de episode/ (no caso, o-nome-do-episode)
Feito isso, deletar o arquivo episodes.tsx em /pages (o que acabamos de criar)
Então, se eu acessar http://localhost:3000/episode/qualquer-merda-aqui, será acessado normalmente. E o nome ali será capturado pelo slug

Certo, funciona já. ENTRETANTO, quando é redirecionado para a outra página, tudo é novamente recarregado, e isso não é legal.
Para isso, import Link do next lá na Home

Apesar de ser uma página estática, essa página para um episodio é dinamica. Ou seja, uma página estática dinamica. Pois ela pode ser diferente para cada episódio.
Entao, devemos ter o método getStaticPaths nela tbm

Em description, os dados são retornados com tags do html. Para isso não acontecer, usaremos a propriedade dangerouslySetInnerHTML na div

#astronautas


Dia 4:

getStaticPaths() é um método obrigatório em toda página estática e que tenha parâmetros dinâmicos [slug]

Se o fallback estiver como false e não existir nenhuma rota em paths: [], todas as rotas que nao forem geradas de forma estática serão retornados com erro 404
Se o fallback estiver como true, é possivel que exista erro no build, pois o next precisa fazer a requisição na api, e os dados que utilizamos no jsx podem estarem vazios ainda (carregamento feito no client)
Se fallback estiver como blocking, o usuário só vai para a página solicitada quando os dados estiverem totalmente carregados. E esse carregamento é feito no servidor do next (que roda em node)

blocking é a melhor opção a ser utilizada!

Utilização da contextapi

Criar pasta /contexts

Como o contexto será utilizado em alguns componentes, vamos no arquivo raiz (_app) e inserimos dentro do contexto os componentes que o usarão


Trabalhar com slider para o player, utilizar a lib rc-slider
   yarn add rc-slider

#universoinfinito


Dia 5:

Refatorar o contexto.
Não é um problema deixar os métodos construídos no _app, mas e quando tiver outro contexto lá? Vai ficar uma bagunça
Então, deixaremos os métodos dentro do arquivo de contexto. E mudaremos o formato do arquivo de ts para tsx



O que pode ser melhorado:

Responsividade
PWA
Tema dark (pode usar as cores do omni, da rocketseat)